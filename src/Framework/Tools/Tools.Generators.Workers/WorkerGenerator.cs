using System.Text;
using Common.Extensions;
using Infrastructure.Eventing.Common.Extensions;
using Infrastructure.Eventing.Interfaces.Notifications;
using JetBrains.Annotations;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace Tools.Generators.Workers;

/// <summary>
///     A source generator for creating Azure Functions and AWS Lambdas definitions for each of the
///     <see cref="IDomainEventNotificationConsumer" /> found in the host project.
///     The code that is source generated is generated from an API Host project and then included in another Worker Host
///     project, hence the need to hide the generated code from compiling the API Host project (using #if statements).
/// </summary>
[Generator]
public class WorkerGenerator : ISourceGenerator
{
    internal const string ProjectNameSettingName = "ApplicationServices:EventNotifications:SubscriptionName";
    private const string Filename = "DeliverDomainEvents.g.cs";

    public void Execute(GeneratorExecutionContext context)
    {
        var assemblyName = GetProjectNameFromConfiguration(context);
        var consumerTypes = GetConsumersFromAssemblies(context);
        var consumerNames = consumerTypes
            .Select(consumerType =>
                EventingExtensions.CreateConsumerName($"{consumerType.Name.Namespace}.{consumerType.Name.Name}",
                    assemblyName))
            .ToArray();

        var filename = $"{assemblyName}_{Filename}";
        var fileSource = BuildFile(assemblyName, consumerNames);

        context.AddSource(filename, SourceText.From(fileSource, Encoding.UTF8));

        return;

        static string BuildFile(string assemblyName, string[] consumerNames)
        {
            var builder = new StringBuilder();
            builder.AppendLine("// <auto-generated/>");
            builder.AppendLine("""
                               #if GENERATEDCODEFORAZUREFUNCTIONS
                               using AzureFunctions.Api.WorkerHost.Extensions;

                               namespace AzureFunctions.Api.WorkerHost.Functions;
                               """);
            foreach (var consumerName in consumerNames)
            {
                var className = consumerName
                    .Replace("-", string.Empty);
                var subscriptionName = consumerName.ToLowerInvariant();
                builder.AppendLine($$"""

                                     [JetBrains.Annotations.UsedImplicitly]
                                     public sealed class DeliverDomainEventTo{{className}}
                                     {
                                         private readonly Infrastructure.Workers.Api.IWorkersRuntime _runtime;
                                         private readonly Common.Configuration.IConfigurationSettings _settings;
                                         private readonly Infrastructure.Workers.Api.IMessageBusMonitoringApiRelayWorker<Application.Persistence.Shared.ReadModels.DomainEventingMessage> _worker;
                                     
                                         public DeliverDomainEventTo{{className}}(Infrastructure.Workers.Api.IMessageBusMonitoringApiRelayWorker<Application.Persistence.Shared.ReadModels.DomainEventingMessage> worker, Infrastructure.Workers.Api.IWorkersRuntime runtime, Common.Configuration.IConfigurationSettings settings)
                                         {
                                             _worker = worker;
                                             _runtime = runtime;
                                             _settings = settings;
                                         }
                                     
                                         [Microsoft.Azure.Functions.Worker.Function(nameof(DeliverDomainEventTo{{className}}))]
                                         public async Task Run([Microsoft.Azure.Functions.Worker.ServiceBusTrigger(Application.Interfaces.WorkerConstants.MessageBuses.Topics.DomainEvents, "{{subscriptionName}}", Connection = "ServiceBusConnection", IsSessionsEnabled = true, AutoCompleteMessages = false)] Azure.Messaging.ServiceBus.ServiceBusReceivedMessage receivedMessage, Microsoft.Azure.Functions.Worker.ServiceBusMessageActions actions, Microsoft.Azure.Functions.Worker.FunctionContext context)
                                         {
                                             var handler = new AzureFunctionMessageDeliveryHandler(_settings, actions, _runtime, context.FunctionDefinition.Name);
                                             await handler.HandleDelivery(receivedMessage, _worker, "{{assemblyName}}", "{{subscriptionName}}", context.CancellationToken);
                                         }
                                     }
                                     """);
            }

            builder.AppendLine("""
                               #elif GENERATEDCODEFORAWSLAMBDAS
                               using AWSLambdas.Api.WorkerHost.Extensions;

                               namespace AWSLambdas.Api.WorkerHost.Lambdas;
                               """);
            foreach (var consumerName in consumerNames)
            {
                var className = consumerName
                    .Replace("-", string.Empty);
                var subscriptionName = consumerName.ToLowerInvariant();
                builder.AppendLine($$"""

                                     [JetBrains.Annotations.UsedImplicitly]
                                     public sealed class DeliverDomainEventTo{{className}}
                                     {
                                         private readonly Infrastructure.Workers.Api.IMessageBusMonitoringApiRelayWorker<Application.Persistence.Shared.ReadModels.DomainEventingMessage> _worker;
                                         private readonly Infrastructure.Workers.Api.IWorkersRuntime _runtime;
                                     
                                         public DeliverDomainEventTo{{className}}(Infrastructure.Workers.Api.IMessageBusMonitoringApiRelayWorker<Application.Persistence.Shared.ReadModels.DomainEventingMessage> worker, Infrastructure.Workers.Api.IWorkersRuntime runtime)
                                         {
                                             _worker = worker;
                                             _runtime = runtime;
                                         }
                                     
                                         [Amazon.Lambda.Annotations.LambdaFunction]
                                         public async Task<bool> Run(Amazon.Lambda.SQSEvents.SQSEvent sqsEvent, Amazon.Lambda.Core.ILambdaContext context)
                                         {
                                             var handler = new AWSLambdaMessageDeliveryHandler(_runtime, context.FunctionName, 0);
                                             return await handler.HandleDelivery(sqsEvent, _worker, "{{assemblyName}}", "{{subscriptionName}}", CancellationToken.None);
                                         }
                                     }
                                     """);
            }

            builder.AppendLine("#endif");
            return builder.ToString();
        }
    }

    public void Initialize(GeneratorInitializationContext context)
    {
        // No initialization
    }

    /// <summary>
    ///     Note: we use primitive JSON deserialization because using the .NET standard 2.0 configuration libraries is
    ///     problematic,
    ///     given that this assembly is netstandard2.0
    /// </summary>
    private static string GetProjectNameFromConfiguration(GeneratorExecutionContext context)
    {
        var currentAssemblyName = context.Compilation.Assembly.Identity.Name;
        var appSettingsFile = context.AdditionalFiles
            .FirstOrDefault(af => af.Path.EndsWith("appsettings.json"));
        if (appSettingsFile.NotExists())
        {
            throw new InvalidOperationException(
                Resources.WorkerGenerator_GetAssemblyNameFromConfiguration_MissingAppSettings.Format(
                    currentAssemblyName));
        }

        var appSettingsText = appSettingsFile
            .GetText(context.CancellationToken)?.ToString() ?? "{}";

        var settings = appSettingsText.FromJson<AppSettingsJsonSchema>();

        var projectName = settings.ApplicationServices?.EventNotifications?.SubscriptionName;
        if (projectName.HasNoValue())
        {
            throw new InvalidOperationException(
                Resources.WorkerGenerator_GetAssemblyNameFromConfiguration_MissingSetting.Format(
                    ProjectNameSettingName, currentAssemblyName));
        }

        return projectName;
    }

    private static IReadOnlyList<ApiHostModuleVisitor.NotificationConsumer> GetConsumersFromAssemblies(
        GeneratorExecutionContext context)
    {
        var visitor = new ApiHostModuleVisitor(context.Compilation, context.CancellationToken);
        visitor.Visit(context.Compilation.GlobalNamespace);
        return visitor.ConsumerTypes;
    }

    // ReSharper disable once MemberCanBePrivate.Global
    public class AppSettingsJsonSchema
    {
        public ApplicationServicesSchema? ApplicationServices { get; set; }
    }

    [UsedImplicitly]
    public class ApplicationServicesSchema
    {
        public EventNotificationsSchema? EventNotifications { get; set; }
    }

    [UsedImplicitly]
    public class EventNotificationsSchema
    {
        public string? SubscriptionName { get; set; }
    }
}