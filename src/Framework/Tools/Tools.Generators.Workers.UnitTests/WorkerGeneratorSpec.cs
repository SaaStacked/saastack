extern alias Generators;
using System.Reflection;
using FluentAssertions;
using Generators::JetBrains.Annotations;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Text;
using Xunit;
using Resources = Generators::Tools.Generators.Workers.Resources;
using Workers_WorkerGenerator = Generators::Tools.Generators.Workers.WorkerGenerator;

namespace Tools.Generators.Workers.UnitTests;

[UsedImplicitly]
public class WorkerGeneratorSpec
{
    private static readonly string[] AdditionalCompilationAssemblies = [];

    private static CSharpCompilation CreateCompilation(string sourceCode)
    {
        var assemblyPath = Path.GetDirectoryName(typeof(object).Assembly.Location)!;

        var references = new List<MetadataReference>
        {
            MetadataReference.CreateFromFile(typeof(Workers_WorkerGenerator).Assembly.Location),
            MetadataReference.CreateFromFile(typeof(Binder).GetTypeInfo().Assembly.Location)
        };
        AdditionalCompilationAssemblies.ToList()
            .ForEach(item => references.Add(MetadataReference.CreateFromFile(Path.Combine(assemblyPath, item))));
        var compilation = CSharpCompilation.Create("compilation",
            [
                CSharpSyntaxTree.ParseText(sourceCode)
            ],
            references,
            new CSharpCompilationOptions(OutputKind.ConsoleApplication));

        return compilation;
    }

    [Trait("Category", "Unit.Tooling")]
    public class GivenAConsumerClass
    {
        private GeneratorDriver _driver;

        public GivenAConsumerClass()
        {
            var generator = new Workers_WorkerGenerator();
            _driver = CSharpGeneratorDriver.Create(generator);
        }


        [Fact]
        public void WhenAppSettingsFileIsMissingFromProject_ThenThrows()
        {
            var compilation = CreateCompilation("");

            FluentActions.Invoking(()=> Generate(compilation))
                .Should().Throw<InvalidOperationException>()
                .WithMessage(string.Format(Resources.WorkerGenerator_GetAssemblyNameFromConfiguration_MissingAppSettings, "compilation"));
        }
        
        [Fact]
        public void WhenAppSettingsIsMissingFromFile_ThenThrows()
        {
            var compilation = CreateCompilation("");
            _driver = _driver.AddAdditionalTexts([new AppSettingsAdditionalText("{}")]);

            FluentActions.Invoking(()=> Generate(compilation))
                .Should().Throw<InvalidOperationException>()
                .WithMessage(string.Format(Resources.WorkerGenerator_GetAssemblyNameFromConfiguration_MissingSetting, Workers_WorkerGenerator.ProjectNameSettingName, "compilation"));
        }

        [Fact]
        public void WhenDefinesAConsumer_ThenGenerates()
        {
            var compilation = CreateCompilation("""
                                                using Domain.Interfaces.Entities;
                                                using Infrastructure.Eventing.Interfaces.Notifications;

                                                namespace ANamespace;

                                                public class AConsumerClass : IDomainEventNotificationConsumer
                                                {
                                                    public Task<Result<Error>> NotifyAsync(IDomainEvent domainEvent, CancellationToken cancellationToken)
                                                    {
                                                        return Task.FromResult(Result.Ok);
                                                    }
                                                }
                                                """);
            _driver = _driver.AddAdditionalTexts([new AppSettingsAdditionalText("""
                                                                                {
                                                                                    "ApplicationServices": {
                                                                                        "EventNotifications":{
                                                                                            "SubscriptionName": "aprojectname"
                                                                                        }
                                                                                    }
                                                                                }
                                                                                """)]);

            var result = Generate(compilation);

            result.Should().Be(
                """
                // <auto-generated/>
                #if GENERATEDCODEFORAZUREFUNCTIONS
                using AzureFunctions.Api.WorkerHost.Extensions;
                
                namespace AzureFunctions.Api.WorkerHost.Functions;
                
                [JetBrains.Annotations.UsedImplicitly]
                public sealed class DeliverDomainEventToaprojectnameANamespaceAClass
                {
                    private readonly Infrastructure.Workers.Api.IWorkersRuntime _runtime;
                    private readonly Common.Configuration.IConfigurationSettings _settings;
                    private readonly Infrastructure.Workers.Api.IMessageBusMonitoringApiRelayWorker<Application.Persistence.Shared.ReadModels.DomainEventingMessage> _worker;
                
                    public DeliverDomainEventToaprojectnameANamespaceAClass(Infrastructure.Workers.Api.IMessageBusMonitoringApiRelayWorker<Application.Persistence.Shared.ReadModels.DomainEventingMessage> worker, Infrastructure.Workers.Api.IWorkersRuntime runtime, Common.Configuration.IConfigurationSettings settings)
                    {
                        _worker = worker;
                        _runtime = runtime;
                        _settings = settings;
                    }
                
                    [Microsoft.Azure.Functions.Worker.Function(nameof(DeliverDomainEventToaprojectnameANamespaceAClass))]
                    public async Task Run([Microsoft.Azure.Functions.Worker.ServiceBusTrigger(Application.Interfaces.WorkerConstants.MessageBuses.Topics.DomainEvents, "aprojectname-anamespace-aclass", Connection = "ServiceBusConnection", IsSessionsEnabled = true, AutoCompleteMessages = false)] Azure.Messaging.ServiceBus.ServiceBusReceivedMessage receivedMessage, Microsoft.Azure.Functions.Worker.ServiceBusMessageActions actions, Microsoft.Azure.Functions.Worker.FunctionContext context)
                    {
                        var handler = new AzureFunctionMessageDeliveryHandler(_settings, actions, _runtime, context.FunctionDefinition.Name);
                        await handler.HandleDelivery(receivedMessage, _worker, "aprojectname", "aprojectname-anamespace-aclass", context.CancellationToken);
                    }
                }
                #elif GENERATEDCODEFORAWSLAMBDAS
                using AWSLambdas.Api.WorkerHost.Extensions;
                
                namespace AWSLambdas.Api.WorkerHost.Lambdas;
                
                [JetBrains.Annotations.UsedImplicitly]
                public sealed class DeliverDomainEventToaprojectnameANamespaceAClass
                {
                    private readonly Infrastructure.Workers.Api.IMessageBusMonitoringApiRelayWorker<Application.Persistence.Shared.ReadModels.DomainEventingMessage> _worker;
                    private readonly Infrastructure.Workers.Api.IWorkersRuntime _runtime;
                
                    public DeliverDomainEventToaprojectnameANamespaceAClass(Infrastructure.Workers.Api.IMessageBusMonitoringApiRelayWorker<Application.Persistence.Shared.ReadModels.DomainEventingMessage> worker, Infrastructure.Workers.Api.IWorkersRuntime runtime)
                    {
                        _worker = worker;
                        _runtime = runtime;
                    }
                
                    [Amazon.Lambda.Annotations.LambdaFunction]
                    public async Task<bool> Run(Amazon.Lambda.SQSEvents.SQSEvent sqsEvent, Amazon.Lambda.Core.ILambdaContext context)
                    {
                        var handler = new AWSLambdaMessageDeliveryHandler(_runtime, context.FunctionName, 0);
                        return await handler.HandleDelivery(sqsEvent, _worker, "aprojectname", "aprojectname-anamespace-aclass", CancellationToken.None);
                    }
                }
                #endif

                """);
        }

        private string Generate(CSharpCompilation compilation)
        {
            _driver = _driver.RunGeneratorsAndUpdateCompilation(compilation, out _, out _);
            var result = _driver.GetRunResult().Results[0];
            if (result.Exception != null)
            {
                throw result.Exception!;
            }

            return result.GeneratedSources[0].SourceText.ToString();
        }
    }
}

public class AppSettingsAdditionalText : AdditionalText
{
    private readonly string _text;

    public AppSettingsAdditionalText(string text)
    {
        Path = "appsettings.json";
        _text = text;
    }

    public override string Path { get; }

    public override SourceText GetText(CancellationToken cancellationToken = new())
    {
        return SourceText.From(_text);
    }
}