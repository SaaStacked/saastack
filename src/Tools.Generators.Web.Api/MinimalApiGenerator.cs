using System.Text;
using Application.Interfaces;
using Common.Extensions;
using Infrastructure.Web.Api.Interfaces;
using Infrastructure.Web.Hosting.Common;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using Tools.Analyzers.Common;

namespace Tools.Generators.Web.Api;

/// <summary>
///     A source generator for converting any <see cref="IWebApiService" /> classes to
///     Minimal API registrations
/// </summary>
[Generator]
public class MinimalApiGenerator : ISourceGenerator
{
    private const string Filename = "MinimalApiGeneratedHandlers.g.cs";
    private const string RegistrationClassName = "MinimalApiRegistration";
    private const string TestingOnlyDirective = "TESTINGONLY";

    // ReSharper disable once UseCollectionExpression
    private static readonly string[] RequiredUsingNamespaces =
    {
        "System", "Microsoft.AspNetCore.Builder", "Microsoft.AspNetCore.Http",
        "Microsoft.Extensions.DependencyInjection", "Infrastructure.Web.Api.Common.Extensions"
    };

    public void Execute(GeneratorExecutionContext context)
    {
        var assemblyNamespace = context.Compilation.AssemblyName;
        var serviceClasses = GetWebApiServiceOperationsFromAssembly(context)
            .GroupBy(registrations => registrations.Class.TypeName)
            .ToList();

        var classUsingNamespaces = BuildUsingList(serviceClasses);
        var handlerClasses = new StringBuilder();
        var endpointRegistrations = new StringBuilder();
        foreach (var serviceRegistrations in serviceClasses)
        {
            BuildEndpointRegistrations(serviceRegistrations, endpointRegistrations);
        }

        var fileSource = BuildFile(assemblyNamespace!, classUsingNamespaces, endpointRegistrations.ToString(),
            handlerClasses.ToString());

        context.AddSource(Filename, SourceText.From(fileSource, Encoding.UTF8));

        return;

        static string BuildFile(string assemblyNamespace, string allUsingNamespaces, string allEndpointRegistrations,
            string allHandlerClasses)
        {
            return $@"// <auto-generated/>
{allUsingNamespaces}
namespace {assemblyNamespace}
{{
    public static class {RegistrationClassName}
    {{
        public static void RegisterRoutes(this global::Microsoft.AspNetCore.Builder.WebApplication app)
        {{
    {allEndpointRegistrations}
        }}
    }}
}}

{allHandlerClasses}";
        }
    }

    public void Initialize(GeneratorInitializationContext context)
    {
        // No initialization
    }

    private static string BuildUsingList(
        List<IGrouping<WebApiAssemblyVisitor.TypeName, WebApiAssemblyVisitor.ServiceOperationRegistration>>
            serviceClasses)
    {
        var usingList = new StringBuilder();

        var allNamespaces = serviceClasses.SelectMany(serviceClass => serviceClass)
            .SelectMany(registration => registration.Class.UsingNamespaces)
            .Concat(RequiredUsingNamespaces)
            .Distinct()
            .OrderByDescending(s => s)
            .ToList();

        allNamespaces.ForEach(@using => usingList.AppendLine($"using {@using};"));

        return usingList.ToString();
    }

    private static void BuildEndpointRegistrations(
        IGrouping<WebApiAssemblyVisitor.TypeName, WebApiAssemblyVisitor.ServiceOperationRegistration>
            serviceRegistrations, StringBuilder endpointRegistrations)
    {
        var serviceClassName = serviceRegistrations.Key.Name;
        var groupName = $"{serviceClassName.ToLowerInvariant()}Group";
        var basePath = serviceRegistrations.FirstOrDefault()?.Class.BasePath;
        var prefix = basePath.HasValue()
            ? $"\"{basePath}\""
            : "string.Empty";

        var endpointFilters = BuildEndpointFilters(serviceRegistrations);
        endpointRegistrations.AppendLine($@"        var {groupName} = app.MapGroup({prefix})
                .WithTags(""{serviceClassName}"")
                .RequireCors(""{WebHostingConstants.DefaultCORSPolicyName}""){endpointFilters};");

        foreach (var registration in serviceRegistrations)
        {
            if (registration.IsTestingOnly)
            {
                endpointRegistrations.AppendLine($"#if {TestingOnlyDirective}");
            }

            var routeEndpointMethods = ToHttpMethodNames(registration.OperationMethod);
            foreach (var routeEndpointMethod in routeEndpointMethods)
            {
                var endPointMethodName = $"Map{routeEndpointMethod}";
                var methodBody = BuildHandlerBody(registration);
                endpointRegistrations.AppendLine(
                    $"            {groupName}.{endPointMethodName}(\"{registration.RoutePath}\",");
                endpointRegistrations.AppendLine(
                    $"                async (global::System.IServiceProvider serviceProvider, global::{registration.RequestDto.FullName} request) =>");
                endpointRegistrations.AppendLine(
                    $"                {methodBody})");

                if (registration.OperationAccess != AccessType.Anonymous)
                {
                    var policyName = registration.OperationAccess switch
                    {
                        AccessType.Token => AuthenticationConstants.Authorization.TokenPolicyName,
                        AccessType.HMAC => AuthenticationConstants.Authorization.HMACPolicyName,
                        AccessType.PrivateInterHost => AuthenticationConstants.Authorization.PrivateInterHostPolicyName,
                        _ => string.Empty
                    };
                    if (policyName.HasValue())
                    {
                        endpointRegistrations.AppendLine(
                            $@"                .RequireAuthorization(""{policyName}"")");
                    }
                }

                if (registration.OperationAuthorization is not null)
                {
                    var policyName = registration.OperationAuthorization.PolicyName;
                    endpointRegistrations.AppendLine(
                        $@"                .RequireCallerAuthorization(""{policyName}"")");
                }

                endpointRegistrations.AppendLine(
                    $"                .AddEndpointFilter<global::Infrastructure.Web.Api.Common.Endpoints.ValidationFilter<{registration.RequestDto.FullName}>>()");

                if (registration.IsMultipartFormData
                    || registration.IsFormUrlEncoded)
                {
                    endpointRegistrations.AppendLine(
                        @"                .DisableAntiforgery()");
                }

                if (registration.OperationAccess == AccessType.PrivateInterHost)
                {
                    endpointRegistrations.AppendLine(
                        @"                .ExcludeFromDescription();");
                }
                else
                {
                    var requestDtoName = registration.RequestDto;
                    var openApiName = GenerateOpenApiName(requestDtoName, routeEndpointMethod);
                    endpointRegistrations.AppendLine(
                        @"                .WithOpenApi(op =>");
                    endpointRegistrations.AppendLine(
                        @"                    {");
                    endpointRegistrations.AppendLine(
                        $@"                        op.OperationId = ""{openApiName}"";");
                    endpointRegistrations.AppendLine(
                        $@"                        op.Description = ""(request type: {requestDtoName.Name})"";");
                    endpointRegistrations.AppendLine(
                        @"                        op.Responses.Clear();");
                    endpointRegistrations.AppendLine(
                        @"                        return op;");
                    endpointRegistrations.AppendLine(
                        @"                    });");
                }
            }

            if (registration.IsTestingOnly)
            {
                endpointRegistrations.AppendLine("#endif");
            }
        }

        return;

        string GenerateOpenApiName(WebApiAssemblyVisitor.TypeName requestDtoName, HttpMethod method)
        {
            var name = requestDtoName.Name;

            if (name.EndsWith(AnalyzerConstants.RequestTypeSuffix))
            {
                name = name.Substring(0, name.Length - AnalyzerConstants.RequestTypeSuffix.Length);
            }

            if (method is HttpMethod.Put or HttpMethod.Patch)
            {
                name = $"{name} ({method})";
            }

            return name;
        }
    }

    private static string BuildEndpointFilters(
        IGrouping<WebApiAssemblyVisitor.TypeName, WebApiAssemblyVisitor.ServiceOperationRegistration>
            serviceRegistrations)
    {
        var filterSet = new List<string>
        {
            // Order matters here!
            "global::Infrastructure.Web.Api.Common.Endpoints.HttpRecordingFilter",
            "global::Infrastructure.Web.Api.Common.Endpoints.ApiUsageFilter",
            "global::Infrastructure.Web.Api.Common.Endpoints.RequestCorrelationFilter",
            "global::Infrastructure.Web.Api.Common.Endpoints.ContentNegotiationFilter"
        };
        var isMultiTenanted = serviceRegistrations.Any(registration => registration.IsRequestDtoTenanted);
        if (isMultiTenanted)
        {
            filterSet.Add("global::Infrastructure.Web.Api.Common.Endpoints.MultiTenancyFilter");
        }

        var builder = new StringBuilder();
        var counter = filterSet.Count;
        if (filterSet.HasAny())
        {
            builder.AppendLine();
            filterSet.ForEach(filter =>
            {
                counter--;
                var value = $"                .AddEndpointFilter<{filter}>()";
                if (counter == 0)
                {
                    builder.Append(value);
                }
                else
                {
                    builder.AppendLine(value);
                }
            });
        }

        return builder.ToString();
    }

    private static string BuildHandlerBody(WebApiAssemblyVisitor.ServiceOperationRegistration registration)
    {
        var handlerMethod = new StringBuilder();
        handlerMethod.AppendLine("{");
        handlerMethod.AppendLine(
            "                    return await Handle(serviceProvider, request, global::System.Threading.CancellationToken.None);");
        handlerMethod.AppendLine();
        handlerMethod.AppendLine(
            $"                    static async Task<global::Microsoft.AspNetCore.Http.IResult>"
            + $" Handle(global::System.IServiceProvider services, "
            + $"global::{registration.RequestDto.FullName} request, "
            + $"global::System.Threading.CancellationToken cancellationToken)");
        handlerMethod.AppendLine("                    {");

        if (!registration.IsAsync)
        {
            handlerMethod.AppendLine(
                "                        await Task.CompletedTask;");
        }

        var callingParameters = string.Empty;
        var injectorCtor = registration.Class.Constructors.FirstOrDefault(ctor => ctor.IsInjectionCtor);
        if (injectorCtor is not null)
        {
            var parameters = injectorCtor.CtorParameters.ToList();
            foreach (var param in parameters)
            {
                handlerMethod.AppendLine(
                    $"                        var {param.VariableName} = services.GetRequiredService<{param.TypeName.FullName}>();");
            }

            handlerMethod.AppendLine();
            callingParameters = BuildInjectedParameters(registration.Class.Constructors.ToList());
        }

        handlerMethod.AppendLine(
            $"                        var api = new global::{registration.Class.TypeName.FullName}({callingParameters});");
        var asyncAwait = registration.IsAsync
            ? "await "
            : string.Empty;
        var hasCancellationToken = registration.HasCancellationToken
            ? ", cancellationToken"
            : string.Empty;
        handlerMethod.AppendLine(
            $"                        var result = {asyncAwait}api.{registration.MethodName}(request{hasCancellationToken});");
        handlerMethod.AppendLine(
            $"                        return result.HandleApiResult(global::{typeof(OperationMethod).FullName}.{registration.OperationMethod});");
        handlerMethod.AppendLine("                    }");
        handlerMethod.Append("                }");

        return handlerMethod.ToString();
    }

    private static string BuildInjectedParameters(List<WebApiAssemblyVisitor.Constructor> constructors)
    {
        var methodParameters = new StringBuilder();

        var injectorCtor = constructors.FirstOrDefault(ctor => ctor.IsInjectionCtor);
        if (injectorCtor is not null)
        {
            var parameters = injectorCtor.CtorParameters.ToList();

            var paramsRemaining = parameters.Count();
            foreach (var param in parameters)
            {
                methodParameters.Append($"{param.VariableName}");
                if (--paramsRemaining > 0)
                {
                    methodParameters.Append(", ");
                }
            }
        }

        return methodParameters.ToString();
    }

    private static List<WebApiAssemblyVisitor.ServiceOperationRegistration> GetWebApiServiceOperationsFromAssembly(
        GeneratorExecutionContext context)
    {
        var visitor = new WebApiAssemblyVisitor(context.Compilation, context.CancellationToken);
        visitor.Visit(context.Compilation.Assembly);
        return visitor.OperationRegistrations;
    }

    private static HttpMethod[] ToHttpMethodNames(OperationMethod method)
    {
        return method switch
        {
            OperationMethod.Get => [HttpMethod.Get],
            OperationMethod.Search => [HttpMethod.Get],
            OperationMethod.Post => [HttpMethod.Post],
            OperationMethod.PutPatch => [HttpMethod.Put, HttpMethod.Patch],
            OperationMethod.Delete => [HttpMethod.Delete],
            _ => [HttpMethod.Get]
        };
    }
}